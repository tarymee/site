##  一、主数据模块定义
### 1.1 主数据概念

主数据（Master Data）指的组织中需要跨系统、跨组织共享的核心业务实体数据，是一个组织中最重要、最核心的数据，是单一、准确、权威的数据来源，是组织运行过程中不可或缺的一部分，一般包括组织信息、人员信息、会计科目、银行账户、客户信息、供应商信息、产品信息等。

### 1.2 定位主数据
确定主数据主要是为了能够识别和管理企业中最重要和关键的数据，而且这些数据会影响到企业整个业务流程。因此，企业需要根据自身的业务需求和具体情况来确定主数据。以下是定位主数据的一些方法：

（1）明确企业的业务流程

企业应当根据其业务流程的特点和需求来识别主数据。企业应该对业务流程和业务规则进行深入的了解，明确各个业务环节中需要用到哪些数据，并确定这些数据是否是主数据，从而有效地确定主数据。

（2）将数据与业务实体建立联系

企业可以根据业务实体来确定主数据，例如客户、供应商、产品、设备等。通过将数据与业务实体进行联系，能够清晰地了解这些数据在业务流程中的作用和重要性，从而更加准确地确定主数据。

（3）确定数据的共性

企业应该从数据的特征和属性出发，找出各部门中所使用的数据是否是相同的，如果是相同的，则可以将这些数据统一定义为主数据。

### 1.3 主数据标准
主数据标准是指在企业中由数据管理专业人员起草，由数据管理组织评审、批准和通过的一套规范的标准，用于定义主数据的结构、格式、编码、命名约定、数据元素、数据域及其它相关属性等内容，以及制定相应的管理流程和标准操作规范等，从而使企业能够在不同系统和业务场景下保持数据的一致和准确性。主数据标准从业务属性、技术属性和管理属性三个角度界定主数据：

（1）业务属性：从业务上对主数据的业务特征进行描述，包括数据的中文名称、所属业务领域、业务含义、业务规则、编码、取值范围以及相关标准的关系。

（2）技术属性：从信息系统实现层面对主数据的技术特征的描述，定义了主数据的数据模型和存储结构，包括数据的类型、格式和来源系统等。

（3）管理属性：从管理层面对主数据标准的管理特征进行描述，包括主数据标准的责任部门、审批流程和启停用日期等。

##  二、业务系统主数据分析
### 2.1 现有主数据分类
|中文名 | 表名称 |
|---|---|
|组织|pl_org|
|职位|pl_position|
|人员|pl_userinfo|
|组织架构|pl_orgstruct|
|产品|kx_kq_product|
|行政区域|pl_region|
|字典表|pl_dictionary|
|终端|kx_kq_store|
|分销商|kx_separate_distributor|
|经销商|ka_kq_channelcustomers|

### 2.2 主数据现状

1. 缺少标准：每个租户一套主数据接口和页面，标准和规范不统一
2. 缺少性能：现有业务查询基本依赖主数据和数据权限，性能较差
3. 定义模糊: 哪些是主数据？有什么内置规则，开发和产品并不能得到统一的共识 
4. 缺少通讯机制：主数据变化，其他业务模块不能立刻感知，造成投放范围等多个功能无法达到立即生效


##  三、主数据模块技术选型

### 2.1 aPaaS低码平台配置


优点:
1. 能快速编码，快速搭建一套业务系统
2. 配套的基础设施能力比较稳定，有配套人员进行迭代，经过时间验证了
3. 定制化能力强

缺点:
1. UI/UE受到平台能力限制
2. 封装和可复用能力没那么强，业务逻辑复杂后不易维护，不易迭代
3. 无法使用到一些好的Java开源框架能力




###  2.2 模板式管理页面  （类超表配置）


特点：
领域驱动（模式  +  模板页面）  


分不同功能区域的模板引擎？

* 列表关键字查询、高级查询
* 查询的控件，并非只有下拉、文本、有一些是复选框等，或变成一个状态栏 （tab形状）
*

优点:
1. 零码配置，高度抽象，用户可随意配置字段
2. 页面功能可全靠配置实现，需求变化时不需要重新编码
缺点:
1. 如何承载实际业务的模型？连业务模型都无法描述，何况更抽象一层，而如果已经理解业务模型，抽象的这一层还有意义吗？
2. 更适合作为一种工具，使用在特定场景
3. 难以维护，难以迭代，不过是另一个平台，整套的协议制定复杂，业务属性太差


###  2.3 纯原生开发+扩展配置

产品规划，迭代   (硬编码模式)

优势：
1. 快速迭代，UI/UE可以随时调整
2. 标准化，由产品对外提供配置能力，可迭代
3. 面向对象设计，代码与业务模型高度一致
4. 开源框架生态成熟，出现问题都有解决方案，更方便的进行一些日志，分布式组件进行集成

缺点:
1. 从零搭建一套微服务基础设施成本和复杂度高，可靠性难以保障（复杂度不是由于Java带来的，而是就是有这么多问题需要解决）
2. 系统整套的接口设计，前后端交互，需要重新设计


